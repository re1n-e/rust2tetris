use my_project::gates::*;

mod tests {
    use super::*;

    #[test]
    fn test_not() {
        assert_eq!(not(0), 1);
        assert_eq!(not(1), 0);
    }

    #[test]
    fn test_or() {
        assert_eq!(or(0, 0), 0);
        assert_eq!(or(0, 1), 1);
        assert_eq!(or(1, 0), 1);
        assert_eq!(or(1, 1), 1);
    }

    #[test]
    fn test_or_16() {
        let test_cases = [
            (vec![0u8; 16], vec![0u8; 16], vec![0u8; 16]),
            (vec![0u8; 16], vec![1u8; 16], vec![1u8; 16]),
            (vec![1u8; 16], vec![0u8; 16], vec![1u8; 16]),
            (vec![1u8; 16], vec![1u8; 16], vec![1u8; 16]),
            (vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
            (vec![0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1], vec![0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0], vec![0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1]),
            (vec![0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], vec![1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0], vec![1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0]),
        ];

        for (a, b, expected) in test_cases {
            let a_array: [u8; 16] = a.try_into().unwrap();
            let b_array: [u8; 16] = b.try_into().unwrap();
            let expected_array: [u8; 16] = expected.try_into().unwrap();

            let result = or_16(a_array, b_array);
            assert_eq!(result, expected_array);
        }
    }

    #[test]
    fn test_or_8way() {
        let test_cases = [
            (vec![0u8; 8], 0),
            (vec![1u8; 8], 1),
            (vec![0,0,0,1,0,0,0,0], 1),
            (vec![0,0,0,0,0,0,0,1], 1),
            (vec![0,0,1,0,0,1,1,0], 1),
        ];

        for (input, expected) in test_cases {
            let input_array: [u8; 8] = input.try_into().unwrap();
            let output = or_8way(input_array);
            assert_eq!(output, expected);
        }
    }

    #[test]
    fn test_xor() {
        assert_eq!(xor(0, 0), 0);
        assert_eq!(xor(0, 1), 1);
        assert_eq!(xor(1, 0), 1);
        assert_eq!(xor(1, 1), 0);
    }

    #[test]
    fn test_not_16() {
        let test_cases = [
            (vec![0u8; 16], vec![1u8; 16]),
            (vec![1u8; 16], vec![0u8; 16]),
            (vec![1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], vec![0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]),
            (vec![0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1], vec![1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0]),
        ];

        for (input, expected) in test_cases {
            let input_array: [u8; 16] = input.try_into().unwrap();
            let expected_array: [u8; 16] = expected.try_into().unwrap();

            let result = not_16(input_array);
            assert_eq!(result, expected_array);
        }
    }

    #[test]
    fn test_nand() {
        // Test all possible input combinations for a and b
        assert_eq!(nand(0, 0), 1);
        assert_eq!(nand(0, 1), 1);
        assert_eq!(nand(1, 0), 1);
        assert_eq!(nand(1, 1), 0);
    }

    #[test]
    fn test_and() {
        assert_eq!(and(0, 0), 0);
        assert_eq!(and(0, 1), 0);
        assert_eq!(and(1, 0), 0);
        assert_eq!(and(1, 1), 1);
    }

    #[test]
    fn test_and_16() {
        let test_cases = [
            ([0; 16], [0; 16], [0; 16]),
            ([0; 16], [1; 16], [0; 16]),
            ([1; 16], [0; 16], [0; 16]),
            ([1; 16], [1; 16], [1; 16]),
            ([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], [0; 16]),
            ([0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1], [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0], [0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0]),
            ([0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], [1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0], [0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0]),
        ];

        for (a, b, expected) in test_cases {
            let a_array: [u8; 16] = a;
            let b_array: [u8; 16] = b;
            let expected_array: [u8; 16] = expected;

            let result = and_16(a_array, b_array);
            assert_eq!(result, expected_array);
        }
    }

    #[test]
    fn test_d_mux() {
        let test_cases = [
            (0u8, 0u8, (0u8, 0u8)),
            (0u8, 1u8, (0u8, 0u8)),
            (1u8, 0u8, (1u8, 0u8)),
            (1u8, 1u8, (0u8, 1u8)),
        ];

        for (inp, sel, expected) in test_cases {
            let (out1, out2) = d_mux(inp, sel);
            assert_eq!((out1, out2), expected);
        }
    }

    #[test]
    fn test_dmux_4way() {
        let test_cases = [
            (0u8, [0, 0], (0u8, 0u8, 0u8, 0u8)),
            (0u8, [1, 0], (0u8, 0u8, 0u8, 0u8)),
            (0u8, [0, 1], (0u8, 0u8, 0u8, 0u8)),
            (0u8, [1, 1], (0u8, 0u8, 0u8, 0u8)),
            (1u8, [0, 0], (1u8, 0u8, 0u8, 0u8)),
            (1u8, [1, 0], (0u8, 1u8, 0u8, 0u8)),
            (1u8, [0, 1], (0u8, 0u8, 1u8, 0u8)),
            (1u8, [1, 1], (0u8, 0u8, 0u8, 1u8)),
        ];

        for (inp, sel, expected) in test_cases {
            let (out1, out2, out3, out4) = dmux_4way(inp, sel);
            assert_eq!((out1, out2, out3, out4), expected);
        }
    }

    #[test]
    fn test_dmux_8way() {
        let test_cases = [
            (0u8, [0, 0, 0], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (0u8, [1, 0, 0], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (0u8, [0, 1, 0], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (0u8, [1, 1, 0], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (0u8, [0, 0, 1], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (0u8, [1, 0, 1], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (0u8, [0, 1, 1], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (0u8, [1, 1, 1], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (1u8, [0, 0, 0], (1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (1u8, [1, 0, 0], (0u8, 1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (1u8, [0, 1, 0], (0u8, 0u8, 1u8, 0u8, 0u8, 0u8, 0u8, 0u8)),
            (1u8, [1, 1, 0], (0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8, 0u8)),
            (1u8, [0, 0, 1], (0u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8)),
            (1u8, [1, 0, 1], (0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8)),
            (1u8, [0, 1, 1], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 0u8)),
            (1u8, [1, 1, 1], (0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8)),
        ];

        for (inp, sel, expected) in test_cases {
            let (out1, out2, out3, out4, out5, out6, out7, out8) = dmux_8way(inp, sel);
            assert_eq!((out1, out2, out3, out4, out5, out6, out7, out8), expected);
        }
    }

    #[test]
    fn test_mux() {
        let test_cases = [
            (0u8, 0u8, 0u8, 0u8),
            (0u8, 0u8, 1u8, 0u8),
            (0u8, 1u8, 0u8, 0u8),
            (0u8, 1u8, 1u8, 1u8),
            (1u8, 0u8, 0u8, 1u8),
            (1u8, 0u8, 1u8, 0u8),
            (1u8, 1u8, 0u8, 1u8),
            (1u8, 1u8, 1u8, 1u8),
        ];

        for (a, b, sel, expected) in test_cases {
            let output = mux(a, b, sel);
            assert_eq!(output, expected);
        }
    }

    #[test]
    fn test_mux_16() {
        let test_cases = [
            ([0u8; 16], [0u8; 16], 0u8, [0u8; 16]),
            ([0u8; 16], [0u8; 16], 1u8, [0u8; 16]),
            ([0u8; 16], [0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], 0u8, [0u8; 16]),
            ([0u8; 16], [0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], 1u8, [0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0]),
            ([1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0], [0u8; 16], 0u8, [1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0]),
            ([1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0], [0u8; 16], 1u8, [0u8; 16]),
            ([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], 0u8, [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]),
            ([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], 1u8, [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]),
        ];

        for (a, b, sel, expected) in test_cases {
            let output = mux_16(a, b, sel);
            assert_eq!(output, expected);
        }
    }

    #[test]
    fn test_mux_4way16() {
        let test_cases = [
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0, 0], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [1, 0], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0, 1], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [1, 1], [0u8; 16]),
            ([0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], [1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0], [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], [0, 0], [0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0]),
            ([0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], [1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0], [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], [1, 0], [1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0]),
            ([0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], [1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0], [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], [0, 1], [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]),
            ([0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], [1,0,0,1,1,0,0,0,0,1,1,1,0,1,1,0], [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], [1, 1], [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]),
        ];
    
        for (a, b, c, d, sel, expected) in test_cases {
            let output = mux_4way16(a, b, c, d, sel);
            assert_eq!(output, expected);
        }
    }


    #[test]
    fn test_mux_8way16() {
        let test_cases = [
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0, 0, 0], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [1, 0, 0], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0, 1, 0], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [1, 1, 0], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0, 0, 1], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [1, 0, 1], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0, 1, 1], [0u8; 16]),
            ([0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [0u8; 16], [1, 1, 1], [0u8; 16]),
            ([0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], [0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1], [0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0], [0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1], [0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0], [0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1], [0,1,1,1,1,0,0,0,1,0,0,1,1,0,1,0], [1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1], [0, 0, 0], [0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0]),
            ([0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], [0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1], [0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0], [0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1], [0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0], [0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1], [0,1,1,1,1,0,0,0,1,0,0,1,1,0,1,0], [1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1], [1, 0, 0], [0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1]),
            ([0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0], [0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1], [0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0], [0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1], [0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0], [0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1], [0,1,1,1,1,0,0,0,1,0,0,1,1,0,1,0], [1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1], [0, 1, 0], [0,0,1,1,0,1,0,0,0,1,0,1,0,1,1,0]),
        ];

        for (a, b, c, d, e, f, g, h, sel, expected) in test_cases {
            let output = mux_8way16(a, b, c, d, e, f, g, h, sel);
            assert_eq!(output, expected);
        }
    }    
}
